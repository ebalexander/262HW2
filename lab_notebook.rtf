{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid1\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww12600\viewh10200\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 -------------\
Mar 2 EA\
-------------\
- read spec, set up repo\
- initial thoughts, shared by Eric: use python, sounds fun\
- files pieces needed: process code, log files, analysis code for log files\
- design considerations: should put a good bit of thought and discussion into log file format,\
  that seems like most important piece, also get to set msg protocol (simple to self-roll)\
- things that need to go into log:\
	once: timescale (if that's what we want to call it)\
	per step: system time, LC at end, operation, op details if message (sender/recipient, their LC?)\
		- track message queue length (wrt LC or system time?)\
		- other sender/recip info? their LC, their timescale?\
		- is logging internal events a can, must, or should?\
- analysis possibilities:\
	- independent vars: range of timescale, specifically set timescales, sending probabilities\
	- dependent vars: (prob histograms of) jump size, drift in LC values across processes, queue 				  length, gaps\
- plan for first steps: helloworld.py to brush up on python, chat app to see sockets, \
			    write skeleton for pieces, log spec to be discussed before going into detail\
	- need to pick between python 2 and 3, 3 has been rec'd to me but should prob decide \
	  based on sockets (recall - our chat app had a py socket lib that meant it wouldn't run\
	  on windows machines, but googling suggests atexit? should ask that half of the group)\
	- py3 seems to have decent socket library, will go with that for now, can change back if Eric\
	  strongly opposed.\
- what does each process need to do:\
 	- on init, randomly set timescale, init LC and system time\
	- per cycle:\
		- wait a lot, according to time scale\
		- send messages, possibly\
		- update LC\
	- always: be receiving messages\
- actually, I think we need initializer to introduce them all to each other/give them each other's sockets, their own log file location, so each process' main should take in a timescale, filename, and 3 sockets and those will be in threads started by the initializing program? played around with threads, realized that to keep memory separate need to use multiprocessing rather than threading.\
- log entries and messages seem like they might benefit from having version numbers (do messages need to do anything except contain an LC value?) --- this may change, but for now in code the message queue is just a list of LC values\
- is anything going to be upset about force quitting the processes? do we need to close the log files?\
 - very possible that I'm doing waiting wrong (not actually using wait())\
- SUMMARY: played around, looked into threads and multiprocessing and writing to file, drafted skeleton code for processes and initializer with missing pieces (messaging and logging) in lines starting with ###\
- NEXT STEPS: talk about options for log and message formats, design first pass analysis, figure out sockets\
\
Meeting Emma and Eric 3/3/16:\
- Need to do socket connections\
- how to format messages and log:\
	- messages: only need logical clock, check that it\'92s an int\
	- log format: system time \\t clock time \\t some encoding for operation\
	- header for log file?\
- Eric does socket by sunday night\
- code for analyzing gaps and all that (plot logical clocks for each process vs system clock): Emma\
- log code: Emma\
- next meeting: monday\
\
-------------\
Mar 8 EA\
-------------\
Update: Eric added sockets, can start running tests\
Turns out there's an issue with our listening and waiting threads plan, because only one thread can have the global interpreter lock at a time.\
But just running code seems fine? Maybe because we have that if statement rather than sleeping.\
I'm going to run it and look at the logs.\
-> having some trouble, looks like regardless of time scale, each log entry is 1 sec apart\
- put in counter, we check system time 10k times per op. So that's\'85.worse design than I'd thought.\
Definitely need to sleep, which means working out this GIL business.\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 -> online tutorials don't address this problem, hard to find info on it, but threads can .wait_for(predicate,timeout), http://jessenoller.com/blog/2009/02/01/python-threads-and-the-global-interpreter-lock night be helpful\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 -> should have a lock on the shared message queue, though\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
SUMMARY: took out global message queue, added logging, \
		  drafted analysis code (still want to do max(LC)-min(LC) hist),\
		  added comments, general debugging\
NEXT STEPS: work out sleeping and listening, honestly super confused about what we are and aren't allowed to use for this assignment, thought it was on the course message board but it isn't\
\
\
}