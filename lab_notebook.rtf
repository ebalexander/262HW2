{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12600\viewh10200\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 -------------\
Mar 2 EA\
-------------\
- read spec, set up repo\
- initial thoughts, shared by Eric: use python, sounds fun\
- files pieces needed: process code, log files, analysis code for log files\
- design considerations: should put a good bit of thought and discussion into log file format,\
  that seems like most important piece, also get to set msg protocol (simple to self-roll)\
- things that need to go into log:\
	once: timescale (if that's what we want to call it)\
	per step: system time, LC at end, operation, op details if message (sender/recipient, their LC?)\
		- track message queue length (wrt LC or system time?)\
		- other sender/recip info? their LC, their timescale?\
		- is logging internal events a can, must, or should?\
- analysis possibilities:\
	- independent vars: range of timescale, specifically set timescales, sending probabilities\
	- dependent vars: (prob histograms of) jump size, drift in LC values across processes, queue 				  length, gaps\
- plan for first steps: helloworld.py to brush up on python, chat app to see sockets, \
			    write skeleton for pieces, log spec to be discussed before going into detail\
	- need to pick between python 2 and 3, 3 has been rec'd to me but should prob decide \
	  based on sockets (recall - our chat app had a py socket lib that meant it wouldn't run\
	  on windows machines, but googling suggests atexit? should ask that half of the group)\
	- py3 seems to have decent socket library, will go with that for now, can change back if Eric\
	  strongly opposed.\
- what does each process need to do:\
 	- on init, randomly set timescale, init LC and system time\
	- per cycle:\
		- wait a lot, according to time scale\
		- send messages, possibly\
		- update LC\
	- always: be receiving messages\
- actually, I think we need initializer to introduce them all to each other/give them each other's sockets, their own log file location, so each process' main should take in a timescale, filename, and 3 sockets and those will be in threads started by the initializing program? played around with threads, realized that to keep memory separate need to use multiprocessing rather than threading.\
- log entries and messages seem like they might benefit from having version numbers (do messages need to do anything except contain an LC value?) --- this may change, but for now in code the message queue is just a list of LC values\
- is anything going to be upset about force quitting the processes? do we need to close the log files?\
 - very possible that I'm doing waiting wrong (not actually using wait())\
- SUMMARY: played around, looked into threads and multiprocessing and writing to file, drafted skeleton code for processes and initializer with missing pieces (messaging and logging) in lines starting with ###\
- NEXT STEPS: talk about options for log and message formats, design first pass analysis, figure out sockets}